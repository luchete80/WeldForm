diff --git a/CMakeLists.txt b/CMakeLists.txt
index 185aad6..c95e134 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -86,7 +86,7 @@ SET(EXES
 	#Cantilever2
 	#Cantilever2_pl
 	#Contact_Neighbours
-	Contact_Compression
+	#Contact_Compression
 	CompressionForces
 	#CompressionForces_Ghost
 	#Compression_Free
diff --git a/CompressionForces.cpp b/CompressionForces.cpp
index 59741df..671e527 100644
--- a/CompressionForces.cpp
+++ b/CompressionForces.cpp
@@ -95,7 +95,7 @@ int main(int argc, char **argv) try
 		Fy	= 300.e6;
     	//dx	= L / (n-1);
 		//dx = L/(n-1);
-		dx = 0.025;
+		dx = 0.015;
     h	= dx*1.2; //Very important
         Cs	= sqrt(K/rho);
 
@@ -122,8 +122,8 @@ int main(int argc, char **argv) try
 		cout << "Particle count: "<<dom.Particles.Size()<<endl;
 		
 		forcepart_count = 0;
-		//dom.gradKernelCorr = true;
-		//dom.ts_nb_inc = 1;		
+		dom.gradKernelCorr = true;
+		dom.ts_nb_inc = 1;		
 		
     	for (size_t a=0; a<dom.Particles.Size(); a++)
     	{
diff --git a/Contact_Compression.cpp b/Contact_Compression.cpp
index 3f6d2f8..2150e38 100644
--- a/Contact_Compression.cpp
+++ b/Contact_Compression.cpp
@@ -77,7 +77,7 @@ int main(){
 	Fy	= 300.e6;
 	//dx	= L / (n-1);
 	//dx = L/(n-1);
-	dx = 0.025;
+	dx = 0.015;
 	h	= dx*1.2; //Very important
 	Cs	= sqrt(K/rho);
 
@@ -111,7 +111,8 @@ int main(){
 	//mesh.v = Vec3_t(0.,0.,);
 	mesh.CalcSpheres(); //DONE ONCE
 	
-
+	dom.ts_nb_inc = 1;
+	
 	for (size_t a=0; a<dom.Particles.Size(); a++)
 	{
 		dom.Particles[a]->G		= G;
@@ -138,10 +139,8 @@ int main(){
 			// dom.Particles[a]->ID=3;
 	}
 	//Contact Penalty and Damping Factors
-	dom.ts_nb_inc = 5;
 	dom.contact = true;
-	//dom.gradKernelCorr = true;
-	//dom.friction = 0.15;
+	dom.friction = 0.15;
 	dom.PFAC = 1.0;
 	dom.DFAC = 0.2;
 	dom.update_contact_surface = false;
diff --git a/Kernel_Test_2D_vel.cpp b/Kernel_Test_2D_vel.cpp
index cc97fee..e00c4bf 100644
--- a/Kernel_Test_2D_vel.cpp
+++ b/Kernel_Test_2D_vel.cpp
@@ -62,15 +62,28 @@ int main(int argc, char **argv) try
   
   cout << "Done"<<endl;
   
-  std::vector<double>  vx(dom.Particles.Size());
+  std::vector<Vec3_t>  v(dom.Particles.Size());
   std::vector<Vec3_t> dfx(dom.Particles.Size());
 
   std::vector<Vec3_t> dfx_c(dom.Particles.Size());
 
   std::vector< Mat3_t > grad_vx(dom.Particles.Size());
+  std::vector< Mat3_t > grad_vx_c(dom.Particles.Size());
 	
   std::vector<double>  gx(dom.Particles.Size());
+  
+  std::vector<Vec3_t>  vij(dom.Particles.Size());
+
+///////////////////////////////////////
+///// DEFINING VELOCITY FIELD:
+
+for (int i = 0; i<dom.Particles.Size();i++) {
+		double x = dom.Particles[i]->x(0);
+		double y = dom.Particles[i]->x(1);
 
+		vx[i](0) = (y-0.5)*(y-0.5) + x;
+		vx[i](1) = x;
+	}
 
  cout << "Calculating Corrected Kernel Gradient..."<<endl;	
 	dom.CalcGradCorrMatrix();
@@ -97,21 +110,18 @@ int main(int argc, char **argv) try
       double K	= SPH::Kernel(Dimension, 0, norm(xij)/h, h);
       double GK = SPH::GradKernel(Dimension, 0, norm(xij)/h, h);     
       
-      Vec3_t vx = 
       
       cout << "r, K, GK: "<<norm(xij)/h<<", "<<K<<", "<<GK<<endl;
       cout <<"Vi"<<mj/dj<<endl;
 
       //grad va = Sum b (vb-va) X gradWb(xa)
+      //Bonet et. al 1999 eqn (43)
+      vij = vx[j] - vx[i];
+      Mat3_t t;
+			Dyad (vij, Vec3_t(GK*xij),t);
       
-      vx[i] += mj/dj * (1 + P2->x(0))*(1.+P2->x(1)) * K;
-      vx[j] += mi/di * (1 + P1->x(0))*(1.+P1->x(1)) * K;
-      
-      // gx[i] += /*mj/dj*/ /*dx * */P2->x(0)* K;
-      // gx[j] += /*mi/di*/ /*dx * */P1->x(0)* K;
-      
-      dfx[i] += mj/dj * (1 + P2->x(0))*(1.+P2->x(1)) * GK * xij;
-      dfx[j] -= mi/di * (1 + P1->x(0))*(1.+P1->x(1)) * GK * xij;
+      grad_vx[i] += mj/dj * t
+      grad_vx[j] -= mi/di * t;
 			
 			Vec3_t GK_ci, GK_cj; 
 
diff --git a/Source/Contact.cpp b/Source/Contact.cpp
index 11e76d7..ec8e459 100644
--- a/Source/Contact.cpp
+++ b/Source/Contact.cpp
@@ -261,7 +261,7 @@ void Domain::CalcContactForces(){
 	max_contact_force = sqrt (max_contact_force);
 	min_contact_force = sqrt (min_contact_force);
 	if (max_contact_force > 0.){
-		cout << "Min Contact Force"<< min_contact_force<<"Max Contact Force: "<< max_contact_force << "Time: " << Time << ", Pairs"<<inside_pairs<<endl;
+		//cout << "Min Contact Force"<< min_contact_force<<"Max Contact Force: "<< max_contact_force << "Time: " << Time << ", Pairs"<<inside_pairs<<endl;
 		//cout << " Min tstep size: " << min_force_ts << ", current time step: " << deltat <<endl;
 		//TEMP
 		// if (min_force_ts> 0)
diff --git a/Source/Domain.cpp b/Source/Domain.cpp
index b946694..7b73a97 100644
--- a/Source/Domain.cpp
+++ b/Source/Domain.cpp
@@ -168,10 +168,9 @@ inline void Domain::AdaptiveTimeStep()
 	}
 	
 	if (contact){
-		if (min_force_ts < deltat){
-			cout << "Step size changed minimum Contact Forcess time: " << 	min_force_ts<<endl;
-			deltat = min_force_ts;
-		}
+		if (min_force_ts < deltat)
+		//cout << "Step size changed minimum Contact Forcess time: " << 	min_force_ts<<endl;
+		deltat = min_force_ts;
 	}
 
 	if (deltat<(deltatint/1.0e5))
@@ -1152,7 +1151,7 @@ inline void Domain::CalcGradCorrMatrix () {
 }
 
 inline void Domain::Move (double dt) {
-
+	//cout << "BEGIN MOVE Time " << Time << "------------------------------"<<endl;
 	#pragma omp parallel for schedule (static) num_threads(Nproc)
 	for (int i=0; i<Particles.Size(); i++)
 		if (Particles[i]->IsFree) {
@@ -1170,10 +1169,10 @@ inline void Domain::Move (double dt) {
 			}
 			//cout << "Particle: "<<i<<endl;
 			Particles[i]->Move(dt,DomSize,TRPR,BLPF,Scheme,I);
-    // if (i==2421){
-      // if (Particles[i]->eff_strain_rate>0)
-				// cout << "eff strain rate : "<<Particles[i]->eff_strain_rate<<", Ep: "<<Particles[i]->Ep<<endl;
-		// }
+      if (i==624){
+        if (Particles[i]->eff_strain_rate>0)
+          cout << "particle 624, eff strain rate : "<<Particles[i]->eff_strain_rate<<", Et: "<<Particles[i]->Et<<"yield"<<Particles[i]->Sigmay<<endl;
+      }
 		}
 }
 
@@ -1314,10 +1313,8 @@ inline void Domain::Solve (double tf, double dt, double dtOut, char const * TheF
 		CalculateSurface(1);				//After Nb search			
 	}
 	
-	// // TO MODIFY
 	if (gradKernelCorr)
 		CalcGradCorrMatrix();	
-	
 	ClearNbData();
 	
 	while (Time<=tf && idx_out<=maxidx) {
diff --git a/Source/Material.cpp b/Source/Material.cpp
index 9bcbad3..883c7c8 100644
--- a/Source/Material.cpp
+++ b/Source/Material.cpp
@@ -7,7 +7,7 @@ inline double JohnsonCook::CalcYieldStress(const double &strain, const double &s
 	double T_h = (temp - T_t) / (T_m - T_t);
 	double sr = strain_rate;
 	if (strain_rate == 0.0)
-		sr = 0.001;
+		sr = 1.e-5;
 	
 	double sy = (A+B*pow(strain, n))*(1.0 + C * log (sr/ eps_0) ) * (1.0 - pow(T_h,m));
 	
diff --git a/Source/Material.h b/Source/Material.h
index f971380..d15541a 100644
--- a/Source/Material.h
+++ b/Source/Material.h
@@ -60,6 +60,7 @@ public Material_{
   m(m_),n(n_),eps_0(eps_0_),T_m(T_m_),T_t(T_t_)
   {}
 	inline double CalcYieldStress(){}	
+	inline double CalcYieldStress(const double &strain){}	
 	inline double CalcYieldStress(const double &strain, const double &strain_rate, const double &temp);	
 	inline double CalcTangentModulus(const double &strain, const double &strain_rate, const double &temp);
   //~JohnsonCook(){}
diff --git a/Source/Neighbour.cpp b/Source/Neighbour.cpp
index ccb4945..faefe92 100644
--- a/Source/Neighbour.cpp
+++ b/Source/Neighbour.cpp
@@ -167,32 +167,32 @@ inline void Domain::ListGenerate ()
             if (i<0)
             {
                     if ((BLPF(0) - Particles[a]->x(0))<=hmax) i=0;
-                            else std::cout<<"Leaving"<<std::endl;
+                            else std::cout<<"Leaving, particle "<<a<< "yield "<<Particles[a]->Sigmay<<", eff_str_rate "<<Particles[a]->eff_strain_rate<<std::endl;
             }
             if (j<0)
             {
                     if ((BLPF(1) - Particles[a]->x(1))<=hmax) j=0;
-                            else std::cout<<"Leaving"<<std::endl;
+                            else std::cout<<"Leaving particle "<<a<<"yield "<<Particles[a]->Sigmay<<", eff_str_rate "<<Particles[a]->eff_strain_rate<<std::endl;
             }
             if (k<0)
             {
                     if ((BLPF(2) - Particles[a]->x(2))<=hmax) k=0;
-                            else std::cout<<"Leaving"<<std::endl;
+                            else std::cout<<"Leaving particle"<< a << "yield "<<Particles[a]->Sigmay<<", eff_str_rate "<<Particles[a]->eff_strain_rate<<std::endl;
             }
 			if (i>=CellNo[0])
 			{
 					if ((Particles[a]->x(0) - TRPR(0))<=hmax) i=CellNo[0]-1;
-							else std::cout<<"Leaving"<<std::endl;
+							else std::cout<<"Leavin particle "<<a<< "yield "<<Particles[a]->Sigmay<<", eff_str_rate "<<Particles[a]->eff_strain_rate<<std::endl;
 			}
             if (j>=CellNo[1])
             {
                     if ((Particles[a]->x(1) - TRPR(1))<=hmax) j=CellNo[1]-1;
-                            else std::cout<<"Leaving"<<std::endl;
+                            else std::cout<<"Leaving particle "<<a<<"yield "<<Particles[a]->Sigmay<<", eff_str_rate "<<Particles[a]->eff_strain_rate<<std::endl;
             }
             if (k>=CellNo[2])
             {
                     if ((Particles[a]->x(2) - TRPR(2))<=hmax) k=CellNo[2]-1;
-                            else std::cout<<"Leaving"<<std::endl;
+                            else std::cout<<"Leaving particle"<<a<<"yield "<<Particles[a]->Sigmay<<", eff_str_rate "<<Particles[a]->eff_strain_rate<<std::endl;
             }
 
             temp = HOC[i][j][k];
diff --git a/Source/Particle.cpp b/Source/Particle.cpp
index 75ea32b..ea45423 100644
--- a/Source/Particle.cpp
+++ b/Source/Particle.cpp
@@ -566,7 +566,7 @@ inline void Particle::Mat2Leapfrog(double dt) {
 	Mult(RotationRate,ShearStress,RS);
 	double dep =0.;
 	double prev_sy;
-	double Et;
+	//double Et; Now is in particle
 	
 	// Elastic prediction step (ShearStress_e n+1)
 	if (FirstStep)
@@ -574,7 +574,7 @@ inline void Particle::Mat2Leapfrog(double dt) {
 	ShearStressb	= ShearStressa;
 	ShearStressa	= dt*(2.0*G*(StrainRate-1.0/3.0*(StrainRate(0,0)+StrainRate(1,1)+StrainRate(2,2))*OrthoSys::I)+SRT+RS) + ShearStressa;
   
-
+	//cout << "StrainRate"<<StrainRate<<endl;
                         
 	eff_strain_rate = sqrt ( 	0.5*( (StrainRate(0,0)-StrainRate(1,1))*(StrainRate(0,0)-StrainRate(1,1)) +
 																	(StrainRate(1,1)-StrainRate(2,2))*(StrainRate(1,1)-StrainRate(2,2)) +
@@ -616,15 +616,15 @@ inline void Particle::Mat2Leapfrog(double dt) {
 		}
 		else if (Material_model == JOHNSON_COOK ){
 			Sigmay = mat->CalcYieldStress(pl_strain,eff_strain_rate,T);
-			cout << "Yield Stress: "<< Sigmay << ", plstrain"<<pl_strain<<", eff_str_rate"<<eff_strain_rate<<endl;
-			cout << "StrainRate"<<StrainRate<<endl;
+			// cout << "Yield Stress: "<< Sigmay << ", plstrain"<<pl_strain<<", eff_str_rate"<<eff_strain_rate<<endl;
+			// cout << "StrainRate"<<StrainRate<<endl;
 		}
 		else if (Material_model == HOLLOMON ){
 			Sigmay = mat->CalcYieldStress(pl_strain); 
 		}
 			
 		if ( sig_trial > Sigmay) {
-      //cout << "Plastic"<<endl;
+      cout << "Plastic"<<endl;
 			//TODO: USE Same CalcYieldStress function with no arguments and update material "current state" before??
 			//Sigmay = mat->CalcYieldStress(pl_strain, eff_strain_rate, T);
 			if (Material_model == HOLLOMON ){
@@ -659,7 +659,7 @@ inline void Particle::Mat2Leapfrog(double dt) {
 				//cout << "eff strain rate: "<<eff_strain_rate<<endl;			
 				
 				Et = mat->CalcTangentModulus(pl_strain, eff_strain_rate, T); //Fraser 3.54
-        //cout << "Et "<<Et<<endl;
+        cout << "plstrain, eff_strain_rate, Et, yield "<<pl_strain<<", "<<eff_strain_rate<<","<<Et<<", " <<Sigmay<<endl;
 			}
 			if (Material_model > BILINEAR ) {//Else Ep = 0
         //cout << "Calculating Ep"<<endl;
diff --git a/Source/Particle.h b/Source/Particle.h
index b34a670..4bbb906 100644
--- a/Source/Particle.h
+++ b/Source/Particle.h
@@ -134,7 +134,7 @@ namespace SPH {
 		double	Sigmay;		///< Tensile yield stress
 		size_t	Fail;		///< Failure criteria
 		
-		double 	Ep;		//TODO: Move To Material
+		double 	Ep, Et;		//TODO: Move To Material
 		double 	Et_m;	//This not make sens to be a material member since is instantaneous 
 
 		double	V;		///< Volume of a particle
diff --git a/Traction_JC.cpp b/Traction_JC.cpp
index 33277f8..a3a55da 100644
--- a/Traction_JC.cpp
+++ b/Traction_JC.cpp
@@ -1,22 +1,22 @@
-// // **********************************************************************************
-// // * PersianSPH - A C++ library to simulate Mechanical Systems (solids, fluids        * 
-// // *             and soils) using Smoothed Particle Hydrodynamics method              *   
-// // * Copyright (C) 2013 Maziar Gholami Korzani and Sergio Galindo-Torres              *
-// // *                                                                                  *
-// // * This file is part of PersianSPH                                                  *
-// // *                                                                                  *
-// // * This is free software; you can redistribute it and/or modify it under the        *
-// // * terms of the GNU General Public License as published by the Free Software        *
-// // * Foundation; either version 3 of the License, or (at your option) any later       *
-// // * version.                                                                         *
-// // *                                                                                  *
-// // * This program is distributed in the hope that it will be useful, but WITHOUT ANY  *
-// // * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A  *
-// // * PARTICULAR PURPOSE. See the GNU General Public License for more details.         *
-// // *                                                                                  *
-// // * You should have received a copy of the GNU General Public License along with     *
-// // * PersianSPH; if not, see <http://www.gnu.org/licenses/>                           *
-// // ************************************************************************************/
+/***********************************************************************************
+* PersianSPH - A C++ library to simulate Mechanical Systems (solids, fluids        * 
+*             and soils) using Smoothed Particle Hydrodynamics method              *   
+* Copyright (C) 2013 Maziar Gholami Korzani and Sergio Galindo-Torres              *
+*                                                                                  *
+* This file is part of PersianSPH                                                  *
+*                                                                                  *
+* This is free software; you can redistribute it and/or modify it under the        *
+* terms of the GNU General Public License as published by the Free Software        *
+* Foundation; either version 3 of the License, or (at your option) any later       *
+* version.                                                                         *
+*                                                                                  *
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY  *
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A  *
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.         *
+*                                                                                  *
+* You should have received a copy of the GNU General Public License along with     *
+* PersianSPH; if not, see <http://www.gnu.org/licenses/>                           *
+************************************************************************************/
 
 #include "Domain.h"
 
@@ -33,11 +33,11 @@ void UserAcc(SPH::Domain & domi)
 		vtraction = VMAX/TAU * domi.getTime();
 	else
 		vtraction = VMAX;
-  
-  vtraction = 0.1; //DIviding by Lo of Traction probe gives str_rate=1.
 	
+  vtraction = 1.0;
+  
 	#pragma omp parallel for schedule (static) num_threads(domi.Nproc)
-
+  
 	#ifdef __GNUC__
 	for (size_t i=0; i<domi.Particles.Size(); i++)
 	#else
@@ -76,48 +76,43 @@ int main(int argc, char **argv) try
     	dom.Kernel_Set(Qubic_Spline);
     	dom.Scheme	= 1;	//Mod Verlet
 			//dom.XSPH	= 0.5; //Very important
-                      
+			
 
         double dx,h,rho,K,G,Cs,Fy;
     	double R,L,n;
 		double Lz_side,Lz_neckmin,Lz_necktot,Rxy_center;
 		
-    	R	= 0.075;
-
-		Lz_side =0.2;
-		Lz_neckmin = 0.050;
-		Lz_necktot = 0.100;
-		Rxy_center = 0.050;
-		L = 2. * Lz_side + Lz_necktot;
-		
-		double E  = 210.e9;
-		double nu = 0.3;
+	R	= 0.075;
 
-      Elastic_ el(E,nu);              
+	Lz_side =0.2;
+	Lz_neckmin = 0.050;
+	Lz_necktot = 0.100;
+	Rxy_center = 0.050;
+	L = 2. * Lz_side + Lz_necktot;
 
+	double E  = 210.e9;
+	double nu = 0.3;
 
+	rho	= 7850.0;
+	K= E / ( 3.*(1.-2*nu) );
+	G= E / (2.* (1.+nu));
+	Fy	= 350.e6;
+	
+	Elastic_ el(E,nu);
+///// MATERIAL CONSTANTS EXAMPLE FROM
+///// Zhang_2017 (Aluminium)
       double A,B,C,n_,m,T_m,T_t,eps_0;
-      A = 175.; B = 380.0; C = 0.0015;
+      A = 175.e6; B = 380.0e6; C = 0.0015;
       m = 1.0;  n_ = 0.34; eps_0 = 1.0;
       T_m = 775.; T_t = 273.;
-      
-//Material A (MPa) B (MPa) C      n     m   Troom (K) Tmelt (K)
-//Aluminum 175      380    0.0015 0.34 1.00 273       775			
-//JohnsonCook(const double &a, const double &b, const double &c, const double &eps_0):
-	// JohnsonCook(const double &a, const double &b, const double &c, 
-              // const double &m_, const double &n_, const double &eps_0_, 
-              // const double &T_m_, const double &T_t_)
-			JohnsonCook mat(el, A,B,C,
+			
+	//Hollomon(const double eps0_, const double &k_, const double &m_):
+	//Hollomon mat(el,Fy/E,1220.e6,0.195);
+	JohnsonCook mat(el, A,B,C,
                       m,n_,eps_0,
-                      T_m, T_t);
-                      
-    	rho	= 7850.0;
-		K= E / ( 3.*(1.-2*nu) );
-		G= E / (2.* (1.+nu));
-		Fy	= 350.e6;
-
+                      T_m, T_t);	
 
-		dx = 0.012;
+		dx = 0.010;
     h	= dx*1.2; //Very important
 
         Cs	= sqrt(K/rho);
@@ -147,33 +142,31 @@ int main(int argc, char **argv) try
 
 
 		cout << "Particle count: "<<dom.Particles.Size()<<endl;
-		
-		//Center particle id
+		//6777 if dx=8.5
 		//4081 if dx=10mm
 		//2421 if dx=12mm
-		int id=2421; 
+		
 		//dom.Particles[6777]->print_history = true;
-		dom.Particles[id]->print_history = true; //If dx=10mm
-		dom.Particles[id]->ID = 4;
-		//dom.Particles[2421]->print_history = true;	//Particle 2421, 3 [     -0.006    -0.006     0.242 ]		
-		cout << "Initial Yield Stress: "<<Fy<<endl;
+		dom.Particles[4081]->print_history = true;
+		//dom.Particles[2421]->print_history = true;
+		//dom.Particles[6777]->ID = 1;
+		
     	for (size_t a=0; a<dom.Particles.Size(); a++)
     	{
 				
-				dom.Particles[a]-> Material_model = JOHNSON_COOK;
-			 dom.Particles[a]->mat = &mat;
-        
-        dom.Particles[a]-> T = 273.;
-				// dom.Particles[a]->k_T			=	150.;
-				// dom.Particles[a]->cp_T			=	960.; 
+				dom.Particles[a]-> Material_model = JOHNSON_COOK/*HOLLOMON*/;
+				dom.Particles[a]->mat = &mat;
 				
 				dom.Particles[a]->G		= G;
     		dom.Particles[a]->PresEq	= 0;
+        dom.Particles[a]->T		= 273;
     		dom.Particles[a]->Cs		= Cs;
     		dom.Particles[a]->Shepard	= false;
     		dom.Particles[a]->Material	= 2;
     		dom.Particles[a]->Fail		= 1;
-    		//dom.Particles[a]->Sigmay	= Fy;
+    		//If let this to move function at the begining it fails
+        dom.Particles[a]->Sigmay	= mat.CalcYieldStress(0.0,0.0,273.);
+        cout << "Sigmay"<<dom.Particles[a]->Sigmay<<endl;
     		dom.Particles[a]->Alpha		= 1.0; 
     		dom.Particles[a]->TI			= 0.3;
     		dom.Particles[a]->TIInitDist	= dx;
@@ -190,8 +183,7 @@ int main(int argc, char **argv) try
 //		dom.m_kernel = SPH::iKernel(dom.Dimension,h);	
 
 
-    	//dom.ThermalStructSolve(/*tf0.0105,/*dt*/timestep,/*dtOut*/0.0001,"test06",999);
-      dom.Solve(/*tf*/0.0105,/*dt*/timestep,/*dtOut*/0.0001,"test06",999);
+    	dom.Solve(/*tf*/0.0105,/*dt*/timestep,/*dtOut*/0.0001,"test06",999);
         return 0;
 }
 MECHSYS_CATCH
diff --git a/Traction_JC_OLD.cpp b/Traction_JC_OLD.cpp
new file mode 100644
index 0000000..e4d9958
--- /dev/null
+++ b/Traction_JC_OLD.cpp
@@ -0,0 +1,200 @@
+// // **********************************************************************************
+// // * PersianSPH - A C++ library to simulate Mechanical Systems (solids, fluids        * 
+// // *             and soils) using Smoothed Particle Hydrodynamics method              *   
+// // * Copyright (C) 2013 Maziar Gholami Korzani and Sergio Galindo-Torres              *
+// // *                                                                                  *
+// // * This file is part of PersianSPH                                                  *
+// // *                                                                                  *
+// // * This is free software; you can redistribute it and/or modify it under the        *
+// // * terms of the GNU General Public License as published by the Free Software        *
+// // * Foundation; either version 3 of the License, or (at your option) any later       *
+// // * version.                                                                         *
+// // *                                                                                  *
+// // * This program is distributed in the hope that it will be useful, but WITHOUT ANY  *
+// // * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A  *
+// // * PARTICULAR PURPOSE. See the GNU General Public License for more details.         *
+// // *                                                                                  *
+// // * You should have received a copy of the GNU General Public License along with     *
+// // * PersianSPH; if not, see <http://www.gnu.org/licenses/>                           *
+// // ************************************************************************************/
+
+#include "Domain.h"
+
+#define TAU		0.005
+#define VMAX	1.0
+
+
+
+void UserAcc(SPH::Domain & domi)
+{
+	double vtraction;
+
+	if (domi.getTime() < TAU ) 
+		vtraction = VMAX/TAU * domi.getTime();
+	else
+		vtraction = VMAX;
+  
+  //vtraction = 0.1; //DIviding by Lo of Traction probe gives str_rate=1.
+	
+	#pragma omp parallel for schedule (static) num_threads(domi.Nproc)
+
+	#ifdef __GNUC__
+	for (size_t i=0; i<domi.Particles.Size(); i++)
+	#else
+	for (int i=0; i<domi.Particles.Size(); i++)
+	#endif
+	
+	{
+		if (domi.Particles[i]->ID == 3)
+		{
+			domi.Particles[i]->a		= Vec3_t(0.0,0.0,0.0);
+			domi.Particles[i]->v		= Vec3_t(0.0,0.0,vtraction);
+			domi.Particles[i]->va		= Vec3_t(0.0,0.0,vtraction);
+			domi.Particles[i]->vb		= Vec3_t(0.0,0.0,vtraction);
+//			domi.Particles[i]->VXSPH	= Vec3_t(0.0,0.0,0.0);
+		}
+		if (domi.Particles[i]->ID == 2)
+		{
+			// domi.Particles[i]->a		= Vec3_t(0.0,0.0,0.0);
+			// domi.Particles[i]->v		= Vec3_t(0.0,0.0,0.0);
+			// domi.Particles[i]->vb		= Vec3_t(0.0,0.0,0.0);
+//			domi.Particles[i]->VXSPH	= Vec3_t(0.0,0.0,0.0);
+		}
+	}
+}
+
+
+using std::cout;
+using std::endl;
+
+int main(int argc, char **argv) try
+{
+      SPH::Domain	dom;
+
+      dom.Dimension	= 3;
+      dom.Nproc	= 4;
+    	dom.Kernel_Set(Qubic_Spline);
+    	dom.Scheme	= 1;	//Mod Verlet
+			//dom.XSPH	= 0.5; //Very important
+                      
+
+        double dx,h,rho,K,G,Cs,Fy;
+    	double R,L,n;
+		double Lz_side,Lz_neckmin,Lz_necktot,Rxy_center;
+		
+    	R	= 0.075;
+
+		Lz_side =0.2;
+		Lz_neckmin = 0.050;
+		Lz_necktot = 0.100;
+		Rxy_center = 0.050;
+		L = 2. * Lz_side + Lz_necktot;
+		
+		double E  = 210.e9;
+		double nu = 0.3;
+
+      Elastic_ el(E,nu);              
+
+///// MATERIAL CONSTANTS EXAMPLE FROM
+///// Zhang_2017 (Aluminium)
+      double A,B,C,n_,m,T_m,T_t,eps_0;
+      A = 175.e6; B = 380.0e6; C = 0.0015;
+      m = 1.0;  n_ = 0.34; eps_0 = 1.0;
+      T_m = 775.; T_t = 273.;
+      
+//Material A (MPa) B (MPa) C      n     m   Troom (K) Tmelt (K)
+//Aluminum 175      380    0.0015 0.34 1.00 273       775			
+//JohnsonCook(const double &a, const double &b, const double &c, const double &eps_0):
+	// JohnsonCook(const double &a, const double &b, const double &c, 
+              // const double &m_, const double &n_, const double &eps_0_, 
+              // const double &T_m_, const double &T_t_)
+			// JohnsonCook mat(el, A,B,C,
+                      // m,n_,eps_0,
+                      // T_m, T_t);
+											
+		Hollomon mat(el,Fy/E,1220.e6,0.195);
+                      
+    	rho	= 7850.0;
+		K= E / ( 3.*(1.-2*nu) );
+		G= E / (2.* (1.+nu));
+		Fy	= 350.e6;
+
+
+		dx = 0.010;
+    h	= dx*1.2; //Very important
+
+        Cs	= sqrt(K/rho);
+
+        double timestep;
+        //timestep = (0.2*h/(Cs));
+		
+		//timestep = 2.5e-6;
+		timestep = 5.e-7;
+
+        cout<<"t  = "<<timestep<<endl;
+        cout<<"Cs = "<<Cs<<endl;
+        cout<<"K  = "<<K<<endl;
+        cout<<"G  = "<<G<<endl;
+        cout<<"Fy = "<<Fy<<endl;
+    	dom.GeneralAfter = & UserAcc;
+        dom.DomMax(0) = L;
+        dom.DomMin(0) = -L;
+
+
+		// inline void Domain::AddCylinderLength(int tag, Vec3_t const & V, double Rxy, double Lz, 
+									// double r, double Density, double h, bool Fixed) {
+		//dom.auto_ts = false;
+		dom.AddTractionProbeLength(1, Vec3_t(0.,0.,-Lz_side/5.), R, Lz_side + Lz_side/5.,
+											Lz_neckmin,Lz_necktot,Rxy_center,
+											dx/2., rho, h, false);
+
+
+		cout << "Particle count: "<<dom.Particles.Size()<<endl;
+		
+		//Center particle id
+		//4081 if dx=10mm
+		//2421 if dx=12mm
+		int id=4081; 
+		//dom.Particles[6777]->print_history = true;
+		dom.Particles[id]->print_history = true; //If dx=10mm
+		dom.Particles[id]->ID = 4;
+		//dom.Particles[2421]->print_history = true;	//Particle 2421, 3 [     -0.006    -0.006     0.242 ]		
+		cout << "Initial Yield Stress: "<<Fy<<endl;
+    	for (size_t a=0; a<dom.Particles.Size(); a++)
+    	{
+				
+				dom.Particles[a]-> Material_model = HOLLOMON;
+			 dom.Particles[a]->mat = &mat;
+        
+        dom.Particles[a]-> T = 273.;
+				// dom.Particles[a]->k_T			=	150.;
+				// dom.Particles[a]->cp_T			=	960.; 
+				
+				dom.Particles[a]->G		= G;
+    		dom.Particles[a]->PresEq	= 0;
+    		dom.Particles[a]->Cs		= Cs;
+    		dom.Particles[a]->Shepard	= false;
+    		dom.Particles[a]->Material	= 2;
+    		dom.Particles[a]->Fail		= 1;
+    		dom.Particles[a]->Sigmay	= Fy;
+    		dom.Particles[a]->Alpha		= 1.0; 
+    		dom.Particles[a]->TI			= 0.3;
+    		dom.Particles[a]->TIInitDist	= dx;
+    		double z = dom.Particles[a]->x(2);
+    		if ( z < 0 ){
+    			dom.Particles[a]->ID=2;
+    			dom.Particles[a]->IsFree=false;
+    			dom.Particles[a]->NoSlip=true;    		
+				}
+				if ( z > L )
+    			dom.Particles[a]->ID=3;
+    	}
+		dom.WriteXDMF("maz");
+//		dom.m_kernel = SPH::iKernel(dom.Dimension,h);	
+
+
+    	//dom.ThermalStructSolve(/*tf0.0105,/*dt*/timestep,/*dtOut*/0.0001,"test06",999);
+      dom.Solve(/*tf*/0.0105,/*dt*/timestep,/*dtOut*/0.0001,"test06",999);
+        return 0;
+}
+MECHSYS_CATCH
