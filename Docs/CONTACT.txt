Penalty factor has influence with exists initial penetration

Contact pairs are added in new pair, RIGPairs
Allocate Nb pair is added, in order to simplifty Main Nb algorithm

inline void Domain::AllocateNbPair(const int &temp1, const int &temp2, const int &T){

		if (contact) { //ONLY PAIRS WITH ONE PARTICLE ON THE SURFACE AND ONE PARTICLE ON THE RIGID SURFACE
			// if (  (Particles[temp1]->ID == contact_surf_id && Particles[temp2]->ID == id_free_surf ) || 
						// (Particles[temp1]->ID == id_free_surf && Particles[temp2]->ID == contact_surf_id )) {	
			if (Particles[temp1]->ID == contact_surf_id || Particles[temp2]->ID == contact_surf_id ) {
				if (Particles[temp1]->ID == id_free_surf || Particles[temp2]->ID == id_free_surf ) {
					//cout << "rig pair found! idsurf "<<id_free_surf<<endl;
					
					// Vec3_t xij	= Particles[temp1]->x - Particles[temp2]->x;
					// double r = norm(xij);
					// double rcutoff = ( Particles[temp1]->h + Particles[temp2]->h ) / 2.;
					// //cout << "r, rcutoff, h1, h2"<< r << ", "<< rcutoff << ", "<< Particles[temp1]->h <<", "<<Particles[temp2]->h<<endl;
					// if ( r < 2.0 *rcutoff ){
						//cout << "Found contact pair: "<< temp1 << ", " << temp2 << endl;
						//ContPairs[k].Push(std::make_pair(P1, P2));
						RIGPairs[T].Push(std::make_pair(temp1, temp2));
				
						//FSMPairs[T].Push(std::make_pair(temp1, temp2));
					//}
					//ContPairs[T].Push(std::make_pair(temp1, temp2));
				}
				return;	//If either one particle or another is in the surface 
			}				
		}
			
		if ( CheckRadius(Particles[temp1],Particles[temp2])){
			if (Particles[temp1]->IsFree || Particles[temp2]->IsFree) {
				if (Particles[temp1]->Material == Particles[temp2]->Material)
				{
					if (Particles[temp1]->IsFree*Particles[temp2]->IsFree)//Both free, most common
						SMPairs[T].Push(std::make_pair(temp1, temp2));
					else
						FSMPairs[T].Push(std::make_pair(temp1, temp2)); //TEMPORARY
				} else
					NSMPairs[T].Push(std::make_pair(temp1, temp2));
			}
	}
}



	if (contact){
		MainNeighbourSearch();
		SaveNeighbourData();				//Necesary to calulate surface! Using Particle->Nb (count), could be included in search
		CalculateSurface(1);				//After Nb search			
	}
	ClearNbData();
	
	
			if ( max > MIN_PS_FOR_NBSEARCH || isfirst ){	//TO MODIFY: CHANGE
			if ( ts_i == 0 ){
				clock_beg = clock();
				if (m_isNbDataCleared)
					MainNeighbourSearch/*_Ext*/();
			
			// cout << "RIG Pairs"<<endl;
			// for (int p=0;p<Nproc;p++)
				// cout << RIGPairs[p].size()<<", ";		
				// cout <<endl;

			// cout << "SM Pairs"<<endl;
			// for (int p=0;p<Nproc;p++)
				// cout << SMPairs[p].size()<<", ";		
				// cout <<endl;

			// cout << "Cont Pairs"<<endl;
			// for (int p=0;p<Nproc;p++)
				// cout << ContPairs[p].size()<<", ";		
				// cout <<endl;					
			
			neigbour_time_spent_per_interval += (double)(clock() - clock_beg) / CLOCKS_PER_SEC;
				//cout << "performing contact search"<<endl
				clock_beg = clock();
				if (contact) {
					SaveNeighbourData();				//Necesary to calulate surface! Using Particle->Nb (count), could be included in search
					CalculateSurface(1);				//After Nb search			
					ContactNbSearch();
					SaveContNeighbourData();
					//SaveNeighbourData();	//Again Save Nb data
				}//contact				
				contact_time_spent += (double)(clock() - clock_beg) / CLOCKS_PER_SEC;
			}// ts_i == 0
			isfirst = false;
		}